<html>
<head>
    <title>Game</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%
        }
    </style>
</head>
<body>
    <script src="js/three.js"></script>
    <script src="js/PointerLockControls.js"></script>
    <script src="js/GLTFLoader.js"></script>
    <div id="blocker">

        <div id="instructions">
            <span style="font-size:40px">Click to play</span>
            <br />
            (W, A, S, D = Move, MOUSE = Look around)
        </div>

    </div>
    <script>



        var scene = new THREE.Scene();
        var scene1 = new THREE.Scene();
        var scene2 = new THREE.Scene();
        scene = scene1;
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        var renderer = new THREE.WebGLRenderer();
        var controlsEnabled = false;
        var moveForward = false;
        var moveBackward = false;
        var moveLeft = false;
        var moveRight = false;
        var canJump = false;
        var house;
        var doomGuy;
        var seeDoomGuy = false;
        var parent;
        var doomCollisions = {};
        var building;
        var skyTexture = [];
        var raycasterD = new THREE.Raycaster();
        var directionD = new THREE.Vector3(0, -1, 0);
        var collisionsD = {};
        var skull;
        var skull2;
        var skull3;
        var skullBBox;
        var skullBBox2;
        var skullBBox3;
        var skullCount = 0;
        var doomGuyBBox;
        var mixer;
        var lastFrame = Date.now();
        var walk;
        var run;
        var still;
        var stillToWalk;
        doomGuyBBox = new THREE.Box3();
        var cubeBBox = new THREE.Box3();
        var cube;
        var houseBBoxes = [];
        var buildingBBoxes = [];
        var houseBBoxCount = 40;
        var direction = new THREE.Vector3();
        var seeTitleScreen = true;
        var doomSound;
        var meshTitle;
        var meshStart;
        var meshOption;
        var meshControl;
        var meshUp;
        var meshDown;
        var meshLeft;
        var meshRight;
        var meshFlash;
        var meshVolume;
        var meshBack1;
        var meshBack2;
        var meshExit;
        var meshLook;
        var meshVolume1;
        var meshVolume2;
        var meshVolume3;
        var meshVolume4;
        var meshVolume5;
        var menuSelect = new THREE.Raycaster()



        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        // PointerLock Control source code taken from https://codepen.io/tembling/pen/reZjEw

        var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;


        var manager = new THREE.LoadingManager();
        manager.onStart = function (url, itemsLoaded, itemsTotal) {

            console.log('Started loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.');

        };

        manager.onLoad = function () {

            console.log('Loading complete!');
            console.log(scene.getObjectByName("doomGuy", true));
            house.scale.set(3, 3, 3);
            scene.background = skyTexture;
            setSkullBBoxs();
            chaseSound();
            // ambientNoise();
            setInterval(logDirection, 1000);
            //building.visible = false;
            // house.visible = false;
            animate();

        };


        manager.onProgress = function (url, itemsLoaded, itemsTotal) {

            console.log('Loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.');
        };

        manager.onError = function (url) {

            console.log('There was an error loading ' + url);
        };

        function loadObjects() {
            var loader = new THREE.GLTFLoader(manager);
            loader.load('js/Objects/House/house_3.glb',
                // called when the resource is loaded
                function (gltf) {
                    house = gltf.scene;
                    scene.add(house);
                    house.rotation.y = - Math.PI / 2;
                    house.position.set(55, -2, 30);
                    houseBBoxes[0] = new THREE.Box3(new THREE.Vector3(97.92601422391, -2, 34.15341844895645), new THREE.Vector3(102.06848069827979, 10, 78.65107712409612));
                    houseBBoxes[1] = new THREE.Box3(new THREE.Vector3(101.9259180603165, -2, 34.36070653342341), new THREE.Vector3(139.87796127698655, 10, 37.89793781433861));
                    houseBBoxes[2] = new THREE.Box3(new THREE.Vector3(136.86987439472297, -2, 37.607029122153165), new THREE.Vector3(139.72427104182447, 10, 113.49595653976305));
                    houseBBoxes[3] = new THREE.Box3(new THREE.Vector3(73.8225104675347, -2, 109.97977706103694), new THREE.Vector3(137.63925878535912, 10, 113.86793023790936));
                    houseBBoxes[4] = new THREE.Box3(new THREE.Vector3(73.89429819609268, -2, 83.52235034462691), new THREE.Vector3(78.29069146628301, 10, 110.79158983531276));
                    houseBBoxes[5] = new THREE.Box3(new THREE.Vector3(78.29069146628301, -2, 83.83132369890478), new THREE.Vector3(102.55258961331263, 10, 86.79112362061738));
                    houseBBoxes[6] = new THREE.Box3(new THREE.Vector3(102.05598936666685, -2, 83.05397473204764), new THREE.Vector3(105.30265455528645, 10, 90.44204213247721));
                    houseBBoxes[7] = new THREE.Box3(new THREE.Vector3(101.66524254755797, -2, 78.14923704537244), new THREE.Vector3(105.26433731356099, 10, 80.48333655863605));
                    //hallway
                    houseBBoxes[8] = new THREE.Box3(new THREE.Vector3(102.1672300653852, -2, 76.40571876961706), new THREE.Vector3(118.57570038112543, 10, 79.60202263221525));
                    houseBBoxes[9] = new THREE.Box3(new THREE.Vector3(102.04209337774811, -2, 59.78905469175373), new THREE.Vector3(112.08040314336925, 10, 62.51315826844717));
                    houseBBoxes[10] = new THREE.Box3(new THREE.Vector3(106.00415390790605, -2, 55.583040700425836), new THREE.Vector3(108.17541240346326, 10, 59.73116781749373));
                    //hallway
                    houseBBoxes[11] = new THREE.Box3(new THREE.Vector3(108.13788084640933, -2, 55.58146246614765), new THREE.Vector3(118.57990744816739, 10, 57.93409726729914));
                    houseBBoxes[12] = new THREE.Box3(new THREE.Vector3(113.92470699573826, -2, 57.57490617367147), new THREE.Vector3(116.02508305625377, 10, 62.01632293834936));
                    //hallway
                    houseBBoxes[13] = new THREE.Box3(new THREE.Vector3(116.03535178101785, -2, 60.038133631387936), new THREE.Vector3(118.57570038112543, 10, 72.72578275949073));
                    //hallway
                    houseBBoxes[14] = new THREE.Box3(new THREE.Vector3(116.62917230840127, -2, 52.02254324538407), new THREE.Vector3(118.57990744816739, 10, 56.40227970129457));
                    houseBBoxes[15] = new THREE.Box3(new THREE.Vector3(103.47274420112089, -2, 94.33225409193427), new THREE.Vector3(119.92151493268069, 5, 96.55603211057256));
                    houseBBoxes[16] = new THREE.Box3(new THREE.Vector3(120.74682371829535, -2, 59.53862901985289), new THREE.Vector3(122.58108787965476, 10, 78.75672608810808));
                    //staircase left
                    houseBBoxes[17] = new THREE.Box3(new THREE.Vector3(106.06325638714221, -2, 101.99279800009121), new THREE.Vector3(108.53603036713128, 5, 109.89594887144517));
                    houseBBoxes[18] = new THREE.Box3(new THREE.Vector3(106.06325638714221, -2, 96.52807025309652), new THREE.Vector3(108.53603036713128, 5, 99.12486930594356));
                    houseBBoxes[19] = new THREE.Box3(new THREE.Vector3(102.75237914596876, -2, 93.59451357590211), new THREE.Vector3(104.07440090579423, 5, 106.32693286271763));
                    houseBBoxes[20] = new THREE.Box3(new THREE.Vector3(104.04563588275458, -2, 102.72473068930334), new THREE.Vector3(106.35741905727425, 5, 105.70150361562314));
                    houseBBoxes[21] = new THREE.Box3(new THREE.Vector3(99.14810234678286, -2, 102.84673311258846), new THREE.Vector3(102.4701927602442, 5, 105.9941586203922));
                    houseBBoxes[22] = new THREE.Box3(new THREE.Vector3(99.01081155131915, -2, 108.76097375626866), new THREE.Vector3(100.45465324655719, 5, 110.05809480597372));
                    //staircase right
                    houseBBoxes[23] = new THREE.Box3(new THREE.Vector3(128.88063619456375, -2, 59.53862901985289), new THREE.Vector3(131.38063619456375, 10, 86.55672608810808));
                    houseBBoxes[24] = new THREE.Box3(new THREE.Vector3(130.8168760920504, -2, 84.5926758185213), new THREE.Vector3(132.4579763052896, 5, 86.48373195269879));
                    houseBBoxes[25] = new THREE.Box3(new THREE.Vector3(135.67169674190916, -2, 84.5926758185213), new THREE.Vector3(137.66662293961372, 5, 86.48373195269879));
                    houseBBoxes[26] = new THREE.Box3(new THREE.Vector3(130.8496419822157, -2, 74.61870906474452), new THREE.Vector3(137.46714770727594, 4, 79.90802622820496));
                    houseBBoxes[27] = new THREE.Box3(new THREE.Vector3(122.12668844673371, -2, 59.42179484667289), new THREE.Vector3(129.706469490173, 4, 64.31335288045861));
                    houseBBoxes[28] = new THREE.Box3(new THREE.Vector3(129.2629798569308, -2, 55.03994753509372), new THREE.Vector3(131.7236452168798, 4, 60.114792437903446));
                    houseBBoxes[29] = new THREE.Box3(new THREE.Vector3(131.7236452168798, -2, 55.03994753509372), new THREE.Vector3(133.2445904539804, 4, 59.08564066184938));
                    houseBBoxes[30] = new THREE.Box3(new THREE.Vector3(135.52433486855918, -2, 55.03994753509372), new THREE.Vector3(136.92014319309822, 4, 59.08564066184938));
                    houseBBoxes[31] = new THREE.Box3(new THREE.Vector3(120.81195353525418, -2, 44.85460598627714), new THREE.Vector3(123.36836002979904, 4, 57.29577560969231));
                    houseBBoxes[32] = new THREE.Box3(new THREE.Vector3(120.41991895282634, -2, 36.31434396332208), new THREE.Vector3(123.78127666088803, 5, 42.40199278701425));
                    houseBBoxes[33] = new THREE.Box3(new THREE.Vector3(113.20785474958362, -2, 37.06839142999161), new THREE.Vector3(115.98320813363452, 5, 48.20875468450057));
                    houseBBoxes[34] = new THREE.Box3(new THREE.Vector3(115.98320813363452, -2, 45.38157356103352), new THREE.Vector3(120.95116151756916, 5, 49.476061933511684));
                    houseBBoxes[35] = new THREE.Box3(new THREE.Vector3(101.03194123374467, -2, 55.06100190931044), new THREE.Vector3(104.04633767665882, 5, 57.77163546582174));
                    houseBBoxes[36] = new THREE.Box3(new THREE.Vector3(129.1891253183756, 4.5, 54.31888480089888), new THREE.Vector3(137.49359585119197, 10, 60.31888480089888));
                    houseBBoxes[37] = new THREE.Box3(new THREE.Vector3(120.39636728351383, 4.5, 37.925722871428334), new THREE.Vector3(123.39636728351383, 10, 60.28532910808158));
                    houseBBoxes[38] = new THREE.Box3(new THREE.Vector3(122.92172008110063, 4.5, 60.28532910808158), new THREE.Vector3(124.92172008110063, 10, 61.78532910808158));
                    houseBBoxes[39] = new THREE.Box3(new THREE.Vector3(127.42795102807455, 4.5, 60.28532910808158), new THREE.Vector3(129.1504177923486, 10, 61.78532910808158));
                    console.log(house);
                    for (i = 0; i < houseBBoxCount; i++) {
                        scene.add(new THREE.Box3Helper(houseBBoxes[i], 0xffff00));
                    }
                },
                // called while loading is progressing
                function (xhr) {
                    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                },
                // called when loading has errors
                function (error) {
                    console.log(error);
                });

            loader.load('js/Objects/DoomGuy/doom2.0.glb', function (gltf) {
                doomGuy = gltf.scene;
                scene.add(doomGuy);
                doomGuy.position.set(5, -1.5, 5);
                doomGuy.name = "doomGuy";
                doomGuy.scale.set(1.5, 1.5, 1.5);
                mixer = new THREE.AnimationMixer(gltf.scene);
                walk = mixer.clipAction(gltf.animations[3]);
                run = mixer.clipAction(gltf.animations[0]);
                still = mixer.clipAction(gltf.animations[1]);
                stillToWalk = mixer.clipAction(gltf.animations[2])

            });
            loader.load('js/Objects/scene.gltf', function (gltf) {
                building = gltf.scene;
                scene.add(building);
                building.position.z = -200;
                building.name = "building";
                building.scale.set(3, 3, 3);
				buildingBBoxes[0] = new THREE.Box3(new THREE.Vector3(-90, -2, -14), new THREE.Vector3(-23.00876408876694, 5, -9.388453451478657));
				buildingBBoxes[1] = new THREE.Box3(new THREE.Vector3(-100, -2, -330), new THREE.Vector3(-90, 5, -9.388453451478657));
				buildingBBoxes[2] = new THREE.Box3(new THREE.Vector3(-90, -2, -330), new THREE.Vector3(65.04980172069583, 5, -325));
				buildingBBoxes[3] = new THREE.Box3(new THREE.Vector3(60, -2, -330), new THREE.Vector3(70, 5, -9.388453451478657));
				buildingBBoxes[4] = new THREE.Box3(new THREE.Vector3(-15.0920613152199, -2, -14), new THREE.Vector3( 60, 5,  -9.388453451478657));
				buildingBBoxes[5] = new THREE.Box3(new THREE.Vector3( -15.966864383664787, -2, -48.59637786046328), new THREE.Vector3( -13.577994466304899, 5, -7.155733357143631));
				buildingBBoxes[6] = new THREE.Box3(new THREE.Vector3( -23.60792949085788, -2, -48.59637786046328), new THREE.Vector3( -21.567753938966195, 5, -7.155733357143631));
				buildingBBoxes[7] = new THREE.Box3(new THREE.Vector3(-13.577994466304899 , -2, -48.59637786046328), new THREE.Vector3( -6.569608075483415, 5, -45.01741811272213));
				buildingBBoxes[8] = new THREE.Box3(new THREE.Vector3(-31.22450187934856, -2, -48.59637786046328), new THREE.Vector3( -23.60792949085788, 5, -45.01741811272213));
				buildingBBoxes[9] = new THREE.Box3(new THREE.Vector3( -32.12830036069896, -2, -85.24850818129383), new THREE.Vector3( -28.886100319680687, 5, -48.59637786046328));
				buildingBBoxes[10] = new THREE.Box3(new THREE.Vector3(-9.207947079206612, -2, -70.62737607466957), new THREE.Vector3(-6.210769585678932, 5, -48.09637786046328));
				buildingBBoxes[11] = new THREE.Box3(new THREE.Vector3(-8.081837342604892, -2, -71.38404372152006), new THREE.Vector3(30.67629561232739, 5, -68.46877369773905));
				buildingBBoxes[12] = new THREE.Box3(new THREE.Vector3(-8.081837342604892, -2, -79.88131739905575), new THREE.Vector3( 30.67629561232739, 5, -76.8728586574606));
				buildingBBoxes[13] = new THREE.Box3(new THREE.Vector3(28.28489756122189, -2, -79.88131739905575), new THREE.Vector3(33.18561817851762, 5, -71.38404372152006));		
				buildingBBoxes[14] = new THREE.Box3(new THREE.Vector3( -8.937292154101481, -2, -102.41985118292226), new THREE.Vector3( -6.3382272887653635, 5, -77.33831630839013));
				buildingBBoxes[15] = new THREE.Box3(new THREE.Vector3(-17.6195474409809, -2, -88.39041720671904), new THREE.Vector3(-8.937292154101481, 5, -84.24850716611411));
                buildingBBoxes[16] = new THREE.Box3(new THREE.Vector3( -40.61357912642374, -2,  -88.39041720671904), new THREE.Vector3( -20.078600931479052, 5,  -84.24850716611411));   
				buildingBBoxes[17] = new THREE.Box3(new THREE.Vector3( -39.838131767729564, -2, -120.26351997438088), new THREE.Vector3( -36.6885031602682, 5, -88.39041720671904));
				buildingBBoxes[18] = new THREE.Box3(new THREE.Vector3( -30.999734525317508, -2, -105.0663944305122), new THREE.Vector3( -9.0309734455, 5, -100.22472348609512));
				buildingBBoxes[19] = new THREE.Box3(new THREE.Vector3( -24.20465038507459, -2, -109.55663893482982), new THREE.Vector3( -20.856761281357688, 5, -105.07373817620037));
				buildingBBoxes[20] = new THREE.Box3(new THREE.Vector3( -32.88508082502006, -2, -112.01344685810655), new THREE.Vector3( 2.080701445459354, 5, -108.87403159739915));
				buildingBBoxes[21] = new THREE.Box3(new THREE.Vector3(-38.26886373816189, -2, -111.22237063441783), new THREE.Vector3( -35.26886373816189, 5, -108.46079752089685));
				buildingBBoxes[22] = new THREE.Box3(new THREE.Vector3(-36.937677907979324, -2, -121.28039733719942), new THREE.Vector3(-13.47078686603588, 5, -116.98972417562294));
				buildingBBoxes[23] = new THREE.Box3(new THREE.Vector3( -8.579976972197381, -2, -122.03602732955386), new THREE.Vector3( 2.6893275905817817, 5, -117.83085493715352));	
				buildingBBoxes[24] = new THREE.Box3(new THREE.Vector3( -1.2412857869846246, -2, -174.22155711397872), new THREE.Vector3(1.9322795590893838, 5, -108.55391607575841));
				buildingBBoxes[25] = new THREE.Box3(new THREE.Vector3( -8.844469990910493, -2, -128.34877602889875), new THREE.Vector3( -5.220074631176205, 5, -124.64042169576818));
				buildingBBoxes[26] = new THREE.Box3(new THREE.Vector3( -8.844469990910493, -2, -144.66573563887005), new THREE.Vector3(-5.220074631176205, 5, -140.957381306));
				buildingBBoxes[27] = new THREE.Box3(new THREE.Vector3( -8.844469990910493, -2, -159.006321144), new THREE.Vector3( -5.220074631176205, 5, -155.29796681157583));	
				buildingBBoxes[28] = new THREE.Box3(new THREE.Vector3( -18.15129457498936, -2, -128.43822453), new THREE.Vector3(-13.767757228360768, 5, -124.7298701971735));	
				buildingBBoxes[29] = new THREE.Box3(new THREE.Vector3( -18.15129457498936, -2, -143.551163744), new THREE.Vector3( -13.767757228360768, 5, -139.84280941124828));
				buildingBBoxes[30] = new THREE.Box3(new THREE.Vector3(-18.15129457498936, -2, -159.176201837), new THREE.Vector3(-13.767757228360768, 5, -155.4678475042658));
				buildingBBoxes[31] = new THREE.Box3(new THREE.Vector3( -25.631808196153724, -2, -136.08072139722105), new THREE.Vector3( -21.51199048124603, 5, -120.69363070092543));
				buildingBBoxes[32] = new THREE.Box3(new THREE.Vector3( -65.71261386850388, -2, -135.17514180802206), new THREE.Vector3( -25.274242197864538, 5, -131.47733398896457));
				buildingBBoxes[33] = new THREE.Box3(new THREE.Vector3( -42.02483009252779, -2, -144.12489618148737), new THREE.Vector3( -38.08796962825296, 5, -135.18167714878638));
				buildingBBoxes[34] = new THREE.Box3(new THREE.Vector3( -66.5564073548621, -2, -151.8055678051903), new THREE.Vector3( -61.92750812480117, 5, -134.56343909332037));
				buildingBBoxes[35] = new THREE.Box3(new THREE.Vector3( -57.704817584941374, -2, -144.06225329299727), new THREE.Vector3( -52.964952173066514, 5, -139.9910096124137));
				buildingBBoxes[36] = new THREE.Box3(new THREE.Vector3( -62.38479253621552, -2, -151.446347036166), new THREE.Vector3( -40.59670845765281, 5, -148.396438659328));
				buildingBBoxes[37] = new THREE.Box3(new THREE.Vector3( -42.53772922625414, -2, -188.52793614632537), new THREE.Vector3( -37.75501737003424, 5, -147.78661426523104));
				buildingBBoxes[38] = new THREE.Box3(new THREE.Vector3( -32.74074185164175, -2, -175.17764277556455), new THREE.Vector3( -20.463766228409465, 5, -139.13070066146597));
				buildingBBoxes[39] = new THREE.Box3(new THREE.Vector3( -32.74074185164175, -2, -182.85680035646428), new THREE.Vector3( -28.758552146091002, 5, -175.17764277556455));
				buildingBBoxes[40] = new THREE.Box3(new THREE.Vector3( -9.542665891490739, -2, -166.39398535037458), new THREE.Vector3( -1.003783946488266, 5, -163.22294545318056));
				buildingBBoxes[41] = new THREE.Box3(new THREE.Vector3( -21.348457683906926, -2, -166.39398535037458), new THREE.Vector3( -12.562669579990281, 5, -163.22294545318056));
				buildingBBoxes[42] = new THREE.Box3(new THREE.Vector3(4.372829674798689 , -2, -196.7542145154248), new THREE.Vector3( 11.098909632777085, 5, -170.7172879924516));
				buildingBBoxes[43] = new THREE.Box3(new THREE.Vector3(1.666457727455486, -2, -174.32517516080458), new THREE.Vector3( 7.378223092833654, 5, -170.15839400834545));
				buildingBBoxes[44] = new THREE.Box3(new THREE.Vector3(0.18065017500675273, -2, -196.72188780888303), new THREE.Vector3(4.822905952789095, 5, -194.4759760266357));
				buildingBBoxes[45] = new THREE.Box3(new THREE.Vector3( -0.8516267618441926, -2, -203.90728197095498), new THREE.Vector3( 1.5900659329022757, 5, -195.80987101884514));
				buildingBBoxes[46] = new THREE.Box3(new THREE.Vector3( -15.521708874429216, -2, -205.5033697333386), new THREE.Vector3(-0.0513234679920642, 5, -202.53315686393913));
				buildingBBoxes[47] = new THREE.Box3(new THREE.Vector3( -31.980159611823552, -2, -201.14145039493616), new THREE.Vector3( -27.634640938770726, 5, -185.35113370452223));	
				buildingBBoxes[48] = new THREE.Box3(new THREE.Vector3( -40.286070243492574, -2, -189.95302460712296), new THREE.Vector3(-31.67266438432, 5, -186.20686346747647));
				buildingBBoxes[49] = new THREE.Box3(new THREE.Vector3( -77.09600791286377, -2, -260.22289976762704), new THREE.Vector3( -19.70131821582173, 5, -194.23816567285132));
				buildingBBoxes[50] = new THREE.Box3(new THREE.Vector3( -19.834068297203342, -2, -205.22219986770102), new THREE.Vector3( -18.61843813491992, 5, -201.84277419831108));
				buildingBBoxes[51] = new THREE.Box3(new THREE.Vector3( -14.829596802675029, -2, -229.43125300997232), new THREE.Vector3( -4.335388857816133, 5, -204.5273522845186));
				buildingBBoxes[52] = new THREE.Box3(new THREE.Vector3( -4.335388857816133, -2, -229.26214430180963), new THREE.Vector3( 9.927215269335318, 5, -218.61671016471354));
				buildingBBoxes[53] = new THREE.Box3(new THREE.Vector3( 9.9914086117194, -2, -228.79952550795744), new THREE.Vector3( 11.795327760090283, 5, -217.51918448641655));
				buildingBBoxes[54] = new THREE.Box3(new THREE.Vector3( -14.391856891696666, -2, -243.62350475298922), new THREE.Vector3( -10.43487068527189, 5, -232.1273156476413));
				buildingBBoxes[55] = new THREE.Box3(new THREE.Vector3( -10.628280301869566, -2, -236.77602034762882), new THREE.Vector3( 14.297585358895343, 5, -234.28498303097538));
				buildingBBoxes[56] = new THREE.Box3(new THREE.Vector3( -11.001130960758659, -2, -244.35080816412886), new THREE.Vector3( 3.7677177180017134, 5, -241.42374413767408));
				buildingBBoxes[57] = new THREE.Box3(new THREE.Vector3( 1.103649522370077, -2, -259.7731640882422), new THREE.Vector3( 4.709995930822544, 5, -243.89973091523592));
				
					for (i = 0; i <  buildingBBoxes.length; i++) {
                        scene.add(new THREE.Box3Helper(buildingBBoxes[i], 0xffff00));
                    }		

            });
            loader.load('js/Objects/skull/scene.gltf', function (gltf) {
                skull = gltf.scene;
                skull2 = gltf.scene.clone();
                skull3 = gltf.scene.clone();
                scene.add(skull);
                skull.position.set(110, 1, 101);
                scene.add(skull2);
                skull2.position.set(125.9, 9.6, 62.69);
                scene.add(skull3);
                skull3.position.set(103.38610284366055, 0.5195993892745685, 68.39432633190229);
                skull.visible = false;
                skull2.visible = false;
                skull3.visible = false;
            });
            var backgroundLoader = new THREE.CubeTextureLoader(manager);

            skyTexture = backgroundLoader.load([
                'js/Objects/right.png',
                'js/Objects/left.png',
                'js/Objects/top.png',
                'js/Objects/bottom.png',
                'js/Objects/front.png',
                'js/Objects/back.png',
            ]);
        }
        loadObjects();

        var blocker = document.getElementById('blocker');
        var instructions = document.getElementById('instructions');
        // https://www.html5rocks.com/en/tutorials/pointerlock/intro/
        var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;
        if (havePointerLock) {
            var element = document.body;
            var pointerlockchange = function (event) {
                if (document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element) {
                    controlsEnabled = true;
                    controls.enabled = true;
                    blocker.style.display = 'none';
                } else {
                    controls.enabled = false;
                    blocker.style.display = '-webkit-box';
                    blocker.style.display = '-moz-box';
                    blocker.style.display = 'box';
                    instructions.style.display = '';
                }
            };
            var pointerlockerror = function (event) {
                instructions.style.display = '';
            };
            // Hook pointer lock state change events
            document.addEventListener('pointerlockchange', pointerlockchange, false);
            document.addEventListener('mozpointerlockchange', pointerlockchange, false);
            document.addEventListener('webkitpointerlockchange', pointerlockchange, false);
            document.addEventListener('pointerlockerror', pointerlockerror, false);
            document.addEventListener('mozpointerlockerror', pointerlockerror, false);
            document.addEventListener('webkitpointerlockerror', pointerlockerror, false);
            instructions.addEventListener('click', function (event) {
                instructions.style.display = 'none';
                // Ask the browser to lock the pointer
                element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
                if (/Firefox/i.test(navigator.userAgent)) {
                    var fullscreenchange = function (event) {
                        if (document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element) {
                            document.removeEventListener('fullscreenchange', fullscreenchange);
                            document.removeEventListener('mozfullscreenchange', fullscreenchange);
                            element.requestPointerLock();
                        }
                    };
                    document.addEventListener('fullscreenchange', fullscreenchange, false);
                    document.addEventListener('mozfullscreenchange', fullscreenchange, false);
                    element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;
                    element.requestFullscreen();
                } else {
                    element.requestPointerLock();
                }
            }, false);
        } else {
            instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
        }

        init();

        function init() {

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0xffffff, 0, 750);

            //FlashLight
            //color, intensity, distance, angle, penumbra, decay
            var flashLight = new THREE.SpotLight(0xaabbcc, 4.2, 89.0, (Math.PI / 2), 1.0, 2.0);
            flashLight.angle = 0.5
            //flashLight.position.set(0.5, 1, 0.75);
            //This sets the light to child of camera object
            camera.add(flashLight);
            flashLight.position.set(0, 0, 1);
            flashLight.target = camera;
            //scene.add( light );
            var geometry = new THREE.BoxGeometry(100, 100, 100);
            var material = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            material.transparent = true;
            material.opacity = 0;
            cube = new THREE.Mesh(geometry, material);
            camera.add(cube);
            cube.position.set(0, 0, -75);
            geometry = new THREE.PlaneGeometry(3000, 3000);
            material = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide });
            material.transparent = true;
            material.opacity = 0;
            var plane = new THREE.Mesh(geometry, material);
            scene.add(plane);
            plane.rotateX(- Math.PI / 2);
            console.log(plane.position);
            plane.position.y = -3;

            //Controls
            controls = new THREE.PointerLockControls(camera);
            scene.add(controls.getObject());
            var onKeyDown = function (event) {
                switch (event.keyCode) {
                    case 38: // up
                    case 87: // w
                        moveForward = true;
                        break;
                    case 37: // left
                    case 65: // a
                        moveLeft = true; break;
                    case 40: // down
                    case 83: // s
                        moveBackward = true;
                        break;
                    case 39: // right
                    case 68: // d
                        moveRight = true;
                        break;
                    case 32: // space
                        if (canJump === true) controls.getObject().translateY(10);
                        canJump = false;
                        break;
                    //						case 17: //ctrl
                    //                            if (flashLight.visible == true) {
                    //                                flashLight.visible = false;
                    //                                break;
                    //                            }
                    //                            else {
                    //                                flashLight.visible = true;
                    //                            }
                    case 67:
                        // camera.fov = Math.atan(Math.tan(120 * Math.PI / 360) / camera.aspect) * 360 / Math.PI; // degrees
                        //  camera.updateProjectionMatrix();
                        break;
                }
            };
            var onKeyUp = function (event) {
                switch (event.keyCode) {
                    case 38: // up
                    case 87: // w
                        moveForward = false;
                        break;
                    case 37: // left
                    case 65: // a
                        moveLeft = false;
                        break;
                    case 40: // down
                    case 83: // s
                        moveBackward = false;
                        break;
                    case 39: // right
                    case 68: // d
                        moveRight = false;
                        break;
                }
            };
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);


            window.addEventListener('resize', onWindowResize, false);


        }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }




        function menu() {
            //
            var loader = new THREE.FontLoader();

            loader.load("js/Fonts/Mech_Tech_Regular.json", function (font) {
                let title = new THREE.TextBufferGeometry("[Mood]", {
                    font: font,
                    size: 12,
                    height: 1,
                    curveSegments: 12,
                    bevelThickness: 1,
                    bevelSize: .5,
                    bevelEnabled: true
                });
                title.computeBoundingBox();
                let centerTitle = - 0.5 * (title.boundingBox.max.x - title.boundingBox.min.x);
                let textMatTitle = new THREE.MeshPhongMaterial({ color: 0xff0000, specular: 0xffffff });
                meshTitle = new THREE.Mesh(title, textMatTitle);
                meshTitle.position.set(centerTitle, 5, -65);
                scene.add(meshTitle);

                let start = new THREE.TextBufferGeometry("<Start>", {
                    font: font,
                    size: 8,
                    height: 1,
                    curveSegments: 12,
                    bevelThickness: 1,
                    bevelSize: .5,
                    bevelEnabled: true
                });
                start.computeBoundingBox();
                let centerStart = - 0.5 * (start.boundingBox.max.x - start.boundingBox.min.x);
                let textMatStart = new THREE.MeshPhongMaterial({ color: 0xff0000, specular: 0xffffff });
                meshStart = new THREE.Mesh(start, textMatStart);
                meshStart.position.set(centerStart, -10, -65);
                meshStart.visible = false;
                scene.add(meshStart);

                let option = new THREE.TextBufferGeometry("<Options>", {
                    font: font,
                    size: 8,
                    height: 1,
                    curveSegments: 12,
                    bevelThickness: 1,
                    bevelSize: .5,
                    bevelEnabled: true
                });
                option.computeBoundingBox();
                let centerOption = - 0.5 * (option.boundingBox.max.x - option.boundingBox.min.x);
                let textMatOption = new THREE.MeshPhongMaterial({ color: 0xff0000, specular: 0xffffff });
                meshOption = new THREE.Mesh(option, textMatOption);
                meshOption.position.set(centerOption, -20, -65);
                meshOption.visible = false;
                scene.add(meshOption);

                let exit = new THREE.TextBufferGeometry("Exit", {
                    font: font,
                    size: 8,
                    height: 1,
                    curveSegments: 12,
                    bevelThickness: 1,
                    bevelSize: .5,
                    bevelEnabled: true
                });
                exit.computeBoundingBox();
                let centerExit = - 0.5 * (exit.boundingBox.max.x - exit.boundingBox.min.x);
                let textMatExit = new THREE.MeshPhongMaterial({ color: 0xff0000, specular: 0xffffff });
                meshExit = new THREE.Mesh(exit, textMatExit);
                meshExit.position.set(centerExit, -30, -65);
                meshExit.visible = false;
                scene.add(meshExit);

                let controls = new THREE.TextBufferGeometry("Controls", {
                    font: font,
                    size: 8,
                    height: 1,
                    curveSegments: 12,
                    bevelThickness: 1,
                    bevelSize: .5,
                    bevelEnabled: true
                });
                controls.computeBoundingBox();
                let centerControl = - 0.5 * (controls.boundingBox.max.z - controls.boundingBox.min.z);
                let textMatControl = new THREE.MeshPhongMaterial({ color: 0xff0000, specular: 0xffffff });
                meshControl = new THREE.Mesh(controls, textMatControl);
                meshControl.position.set(-40, 0, (centerControl + 20));
                meshControl.rotation.y = Math.PI / 2;
                meshControl.visible = false;
                scene.add(meshControl);



                let volume = new THREE.TextBufferGeometry("Volume", {
                    font: font,
                    size: 8,
                    height: 1,
                    curveSegments: 12,
                    bevelThickness: 1,
                    bevelSize: .5,
                    bevelEnabled: true
                });
                volume.computeBoundingBox();
                let centerVolume = - 0.5 * (volume.boundingBox.max.z - volume.boundingBox.min.z);
                let textMatVolume = new THREE.MeshPhongMaterial({ color: 0xff0000, specular: 0xffffff });
                meshVolume = new THREE.Mesh(volume, textMatVolume);
                meshVolume.position.set(-40, -10, (centerVolume + 20));
                meshVolume.rotation.y = Math.PI / 2;
                meshVolume.visible = false;
                scene.add(meshVolume);

                let back1 = new THREE.TextBufferGeometry("Back", {
                    font: font,
                    size: 8,
                    height: 1,
                    curveSegments: 12,
                    bevelThickness: 1,
                    bevelSize: .5,
                    bevelEnabled: true
                });
                back1.computeBoundingBox();
                let centerBack1 = - 0.5 * (back1.boundingBox.max.z - back1.boundingBox.min.z);
                let textMatBack1 = new THREE.MeshPhongMaterial({ color: 0xff0000, specular: 0xffffff });
                meshBack1 = new THREE.Mesh(back1, textMatBack1);
                meshBack1.position.set(-40, -20, (centerBack1 + 20));
                meshBack1.rotation.y = Math.PI / 2;
                meshBack1.visible = false;
                scene.add(meshBack1);

                let conUp = new THREE.TextBufferGeometry("UP = W", {
                    font: font,
                    size: 8,
                    height: 1,
                    curveSegments: 12,
                    bevelThickness: 1,
                    bevelSize: .5,
                    bevelEnabled: true
                });
                conUp.computeBoundingBox();
                let centerConUp = - 0.5 * (conUp.boundingBox.max.x - conUp.boundingBox.min.x);
                let textMatConUp = new THREE.MeshPhongMaterial({ color: 0xff0000, specular: 0xffffff });
                meshUp = new THREE.Mesh(conUp, textMatConUp);
                meshUp.position.set(centerConUp, 25, -55);
                meshUp.visible = false;
                scene.add(meshUp);

                let conDown = new THREE.TextBufferGeometry("Down = S", {
                    font: font,
                    size: 8,
                    height: 1,
                    curveSegments: 12,
                    bevelThickness: 1,
                    bevelSize: .5,
                    bevelEnabled: true
                });
                conDown.computeBoundingBox();
                let centerConDown = - 0.5 * (conDown.boundingBox.max.x - conDown.boundingBox.min.x);
                let textMatConDown = new THREE.MeshPhongMaterial({ color: 0xff0000, specular: 0xffffff });
                meshDown = new THREE.Mesh(conDown, textMatConDown);
                meshDown.position.set(centerConDown, 15, -55);
                meshDown.visible = false;
                scene.add(meshDown);

                let conLeft = new THREE.TextBufferGeometry("Left = A", {
                    font: font,
                    size: 8,
                    height: 1,
                    curveSegments: 12,
                    bevelThickness: 1,
                    bevelSize: .5,
                    bevelEnabled: true
                });
                conLeft.computeBoundingBox();
                let centerConLeft = - 0.5 * (conLeft.boundingBox.max.x - conLeft.boundingBox.min.x);
                let textMatConLeft = new THREE.MeshPhongMaterial({ color: 0xff0000, specular: 0xffffff });
                meshLeft = new THREE.Mesh(conLeft, textMatConLeft);
                meshLeft.position.set(centerConLeft, 5, -55);
                meshLeft.visible = false;
                scene.add(meshLeft);

                let conRight = new THREE.TextBufferGeometry("Right = D", {
                    font: font,
                    size: 8,
                    height: 1,
                    curveSegments: 12,
                    bevelThickness: 1,
                    bevelSize: .5,
                    bevelEnabled: true
                });
                conRight.computeBoundingBox();
                let centerConRight = - 0.5 * (conRight.boundingBox.max.x - conRight.boundingBox.min.x);
                let textMatConRight = new THREE.MeshPhongMaterial({ color: 0xff0000, specular: 0xffffff });
                meshRight = new THREE.Mesh(conRight, textMatConRight);
                meshRight.position.set(centerConRight, -5, -55);
                meshRight.visible = false;
                scene.add(meshRight);

                let conFlash = new THREE.TextBufferGeometry("Flashlight = CTRL", {
                    font: font,
                    size: 8,
                    height: 1,
                    curveSegments: 12,
                    bevelThickness: 1,
                    bevelSize: .5,
                    bevelEnabled: true
                });
                conFlash.computeBoundingBox();
                let centerConFlash = - 0.5 * (conFlash.boundingBox.max.x - conFlash.boundingBox.min.x);
                let textMatConFlash = new THREE.MeshPhongMaterial({ color: 0xff0000, specular: 0xffffff });
                meshFlash = new THREE.Mesh(conFlash, textMatConFlash);
                meshFlash.position.set(centerConFlash, -15, -55);
                meshFlash.visible = false;
                scene.add(meshFlash);

                let look = new THREE.TextBufferGeometry("<<", {
                    font: font,
                    size: 12,
                    height: 1,
                    curveSegments: 12,
                    bevelThickness: 1,
                    bevelSize: .5,
                    bevelEnabled: true
                });
                look.computeBoundingBox();
                let centerLook = - 0.5 * (look.boundingBox.max.x - look.boundingBox.min.x);
                let textMatLook = new THREE.MeshPhongMaterial({ color: 0xff0000, specular: 0xffffff });
                meshLook = new THREE.Mesh(look, textMatLook);
                meshLook.position.set(centerLook, -10, -55);
                meshLook.visible = false;
                scene.add(meshLook);

                let back2 = new THREE.TextBufferGeometry("Back", {
                    font: font,
                    size: 8,
                    height: 1,
                    curveSegments: 12,
                    bevelThickness: 1,
                    bevelSize: .5,
                    bevelEnabled: true
                });
                back2.computeBoundingBox();

                let textMatBack2 = new THREE.MeshPhongMaterial({ color: 0xff0000, specular: 0xffffff });
                meshBack2 = new THREE.Mesh(back2, textMatBack2);
                meshBack2.position.set(-10, -25, -55);
                meshBack2.visible = false;
                scene.add(meshBack2);

                let volume1 = new THREE.TextBufferGeometry("1", {
                    font: font,
                    size: 8,
                    height: 1,
                    curveSegments: 12,
                    bevelThickness: 1,
                    bevelSize: .5,
                    bevelEnabled: true
                });
                volume1.computeBoundingBox();

                let textMatVolume1 = new THREE.MeshPhongMaterial({ color: 0xff0000, specular: 0xffffff });
                meshVolume1 = new THREE.Mesh(volume1, textMatVolume1);
                meshVolume1.position.set(-30, 0, -55);
                meshVolume1.visible = false;
                scene.add(meshVolume1);

                let volume2 = new THREE.TextBufferGeometry("2", {
                    font: font,
                    size: 8,
                    height: 1,
                    curveSegments: 12,
                    bevelThickness: 1,
                    bevelSize: .5,
                    bevelEnabled: true
                });
                volume2.computeBoundingBox();

                let textMatVolume2 = new THREE.MeshPhongMaterial({ color: 0xff0000, specular: 0xffffff });
                meshVolume2 = new THREE.Mesh(volume2, textMatVolume2);
                meshVolume2.position.set(-15, 0, -55);
                meshVolume2.visible = false;
                scene.add(meshVolume2);

                let volume3 = new THREE.TextBufferGeometry("3", {
                    font: font,
                    size: 8,
                    height: 1,
                    curveSegments: 12,
                    bevelThickness: 1,
                    bevelSize: .5,
                    bevelEnabled: true
                });
                volume3.computeBoundingBox();

                let textMatVolume3 = new THREE.MeshPhongMaterial({ color: 0xff0000, specular: 0xffffff });
                meshVolume3 = new THREE.Mesh(volume3, textMatVolume3);
                meshVolume3.position.set(0, 0, -55);
                meshVolume3.visible = false;
                scene.add(meshVolume3);

                let volume4 = new THREE.TextBufferGeometry("4", {
                    font: font,
                    size: 8,
                    height: 1,
                    curveSegments: 12,
                    bevelThickness: 1,
                    bevelSize: .5,
                    bevelEnabled: true
                });
                volume4.computeBoundingBox();

                let textMatVolume4 = new THREE.MeshPhongMaterial({ color: 0xff0000, specular: 0xffffff });
                meshVolume4 = new THREE.Mesh(volume4, textMatVolume4);
                meshVolume4.position.set(15, 0, -55);
                meshVolume4.visible = false;
                scene.add(meshVolume4);

                let volume5 = new THREE.TextBufferGeometry("5", {
                    font: font,
                    size: 8,
                    height: 1,
                    curveSegments: 12,
                    bevelThickness: 1,
                    bevelSize: .5,
                    bevelEnabled: true
                });
                volume5.computeBoundingBox();

                let textMatVolume5 = new THREE.MeshPhongMaterial({ color: 0xff0000, specular: 0xffffff });
                meshVolume5 = new THREE.Mesh(volume5, textMatVolume5);
                meshVolume5.position.set(30, 0, -55);
                meshVolume5.visible = false;
                scene.add(meshVolume5);

            });
        }

    //    menu()


        var num = 0;
        function menuSystem() {
            camera.getWorldDirection(direction);
            var position = new THREE.Vector3();
            camera.getWorldPosition(position);
            menuSelect.set(position, direction);


            menuTitle = menuSelect.intersectObject(meshTitle, true);
            menuStart = menuSelect.intersectObject(meshStart, true);
            menuOption = menuSelect.intersectObject(meshOption, true);
            menuControl = menuSelect.intersectObject(meshControl, true);
            menuVolume = menuSelect.intersectObject(meshVolume, true);
            menuBack1 = menuSelect.intersectObject(meshBack1, true);
            menuBack2 = menuSelect.intersectObject(meshBack2, true);
            menuExit = menuSelect.intersectObject(meshExit, true);
            menuVolume1 = menuSelect.intersectObject(meshVolume1, true);
            menuVolume2 = menuSelect.intersectObject(meshVolume2, true);
            menuVolume3 = menuSelect.intersectObject(meshVolume3, true);
            menuVolume4 = menuSelect.intersectObject(meshVolume4, true);
            menuVolume5 = menuSelect.intersectObject(meshVolume5, true);

            if (menuTitle[0]) {
                num++;
                meshTitle.material.color.set(0xFFFFFF);
                if (num > 70) {

                    meshStart.visible = true;
                    meshOption.visible = true;
                    meshExit.visible = true;
                    num = 0;

                }
            }
            else if (menuStart[0]) {
                num++;
                meshStart.material.color.set(0xFFFFFF)
                if (num > 70) {
                    num = 0;
                    house.visible = true;
                    camera.position.set(105, 0, 83);
                    doomGuy.position.set(95, -1.5, 75);
                    doomSound.play();
                    ambientNoise();
                    meshTitle.visible = false;
                    meshStart.visible = false;
                    meshOption.visible = false;
                    meshExit.visible = false;
                    doomGuy.visible = true;
                    skull.visible = true;
                    skull2.visible = true;
                    skull3.visible = true;
                    meshLook.visible = false;
                    //seeTitleScreen = false;
                }
            }
            else if (menuOption[0]) {
                num++;
                meshOption.material.color.set(0xFFFFFF);
                if (num > 70) {
                    meshTitle.visible = false;
                    meshStart.visible = false;
                    meshOption.visible = false;
                    meshExit.visible = false;
                    meshControl.visible = true;
                    meshVolume.visible = true;
                    meshBack1.visible = true;
                    meshLook.visible = true;
                    meshLook.position.set(-10, -10, -65);
                    meshLook.rotation.y = 0;
                    meshLook.rotation.z = 0;
                }
            }
            else if (menuControl[0]) {
                num++;
                meshControl.material.color.set(0xFFFFFF);
                if (num > 70) {
                    meshUp.visible = true;
                    meshDown.visible = true;
                    meshLeft.visible = true;
                    meshRight.visible = true;
                    meshFlash.visible = true;
                    meshControl.visible = false;
                    meshVolume.visible = false;
                    meshBack1.visible = false;
                    meshBack2.visible = true;
                    meshLook.position.set(-40, 0, -5);
                    meshLook.rotation.y = Math.PI / 2;
                    meshLook.rotation.z = 90 * (Math.PI / 2);

                }
            }
            else if (menuVolume[0]) {
                num++;
                meshVolume.material.color.set(0xFFFFFF);
                if (num > 70) {
                    meshControl.visible = false;
                    meshVolume.visible = false;
                    meshBack1.visible = false;
                    meshBack2.visible = true;
                    meshLook.position.set(-40, 0, -5);
                    meshLook.rotation.y = Math.PI / 2;
                    meshLook.rotation.z = 90 * (Math.PI / 2);
                    meshVolume1.visible = true;
                    meshVolume2.visible = true;
                    meshVolume3.visible = true;
                    meshVolume4.visible = true;
                    meshVolume5.visible = true;
                    doomSound.play();
                }
            }
            else if (menuVolume1[0]) {
                num++;
                meshVolume1.material.color.set(0xFFFFFF);
                if (num > 70) {
                    doomSound.setVolume(.2);
                }
            }
            else if (menuVolume2[0]) {
                num++;
                meshVolume2.material.color.set(0xFFFFFF);
                if (num > 70) {
                    doomSound.setVolume(.4);
                }
            }
            else if (menuVolume3[0]) {
                num++;
                meshVolume3.material.color.set(0xFFFFFF);
                if (num > 70) {
                    doomSound.setVolume(.6);
                }
            }
            else if (menuVolume4[0]) {
                num++;
                meshVolume4.material.color.set(0xFFFFFF);
                if (num > 70) {
                    doomSound.setVolume(.8);
                }
            }
            else if (menuVolume5[0]) {
                num++;
                meshVolume5.material.color.set(0xFFFFFF);
                if (num > 70) {
                    doomSound.setVolume(1.0);
                }
            }
            else if (menuBack1[0]) {
                num++;
                meshBack1.material.color.set(0xFFFFFF);
                if (num > 70) {
                    meshTitle.visible = true;
                    meshStart.visible = true;
                    meshOption.visible = true;;
                    meshExit.visible = true;
                    meshControl.visible = false;
                    meshVolume.visible = false;
                    meshBack1.visible = false;
                    meshLook.visible = true;
                    meshLook.position.set(-40, 0, -5);
                    meshLook.rotation.y = Math.PI / 2;
                    meshLook.rotation.z = 90 * (Math.PI / 2);
                }
            }
            else if (menuBack2[0]) {
                num++;
                meshBack2.material.color.set(0xFFFFFF);
                if (num > 70) {
                    meshControl.visible = true;
                    meshVolume.visible = true;
                    meshBack1.visible = true;
                    meshUp.visible = false;
                    meshDown.visible = false;
                    meshLeft.visible = false;
                    meshRight.visible = false;
                    meshFlash.visible = false;
                    meshBack2.visible = false;
                    meshLook.visible = false;
                    meshLook.visible = true;
                    meshVolume1.visible = false;
                    meshVolume2.visible = false;
                    meshVolume3.visible = false;
                    meshVolume4.visible = false;
                    meshVolume5.visible = false;
                    meshLook.position.set(-10, -10, -65);
                    meshLook.rotation.y = 0;
                    meshLook.rotation.z = 0;
                    doomSound.stop();
                }
            }
            else if (menuExit[0]) {
                num++;
                meshExit.material.color.set(0xFFFFFF);
                if (num > 70) {

                }
            }
            else {
                meshTitle.material.color.set(0xFF0000);
                meshStart.material.color.set(0xFF0000);
                meshOption.material.color.set(0xFF0000);
                meshExit.material.color.set(0xFF0000);
                meshControl.material.color.set(0xFF0000);
                meshVolume.material.color.set(0xFF0000);
                meshBack1.material.color.set(0xFF0000);
                meshBack2.material.color.set(0XFF0000);
                meshVolume1.material.color.set(0xFF0000);
                meshVolume2.material.color.set(0xFF0000);
                meshVolume3.material.color.set(0xFF0000);
                meshVolume4.material.color.set(0xFF0000);
                meshVolume5.material.color.set(0xFF0000);
                num = 0;
            }
        }


        function doomGuyChase() {
            var player = new THREE.Vector3();				//These two lines create an empty vector and copy the current position of the player into it,
            camera.getWorldPosition(player);            	//so we can make something chase the player.
            doomGuy.translateOnAxis(doomGuy.worldToLocal(player), .01);

        }




        //WORKING ON SOUND HERE
        var listener = new THREE.AudioListener();
        camera.add(listener);
        var audioLoader = new THREE.AudioLoader();

        //AMBIENT SOUND
        function ambientNoise() {
            var ambientFloor = new THREE.Audio(listener);
            audioLoader.load('js/Sounds/floorCracking.ogg', function (buffer) {
                ambientFloor.setBuffer(buffer);
                ambientFloor.setLoop(true);
                ambientFloor.setVolume(.5);
                ambientFloor.play();
            });

            var ambientWind = new THREE.Audio(listener);
            audioLoader.load('js/Sounds/howlingWind.ogg', function (buffer) {
                ambientWind.setBuffer(buffer);
                ambientWind.setLoop(true);
                ambientWind.setVolume(.3);
                ambientWind.play();
            });
        }


        //CHASE SOUND
        function chaseSound() {
            doomSound = new THREE.PositionalAudio(listener);
            //doom1.setDirectionalCone(180, 230, 0.1);
            //var helper = new PositionalAudioHelper(doom1, 0.1);
            //doom1.add(helper);
            audioLoader.load('js/Sounds/rip_and_tear.ogg', function (buffer) {
                doomSound.setBuffer(buffer);
                doomSound.setRefDistance(1);
                doomSound.hasPlayBackControl = true;
                //doomSound.play();
            });
            doomGuy.add(doomSound);
        }





        function updateRaycasters() {
            var position = new THREE.Vector3();
            camera.getWorldPosition(position);
            raycasterD.set(position, directionD);
            if (cubeBBox.intersectsBox(doomGuyBBox)) {
                seeDoomGuy = true;
                walk.stop();
                still.play();
            }
            else {
                seeDoomGuy = false;
            }

            collisionsD = raycasterD.intersectObjects(scene.children, true);



        }
        function checkDeath() {
            doomGuyBBox.setFromObject(doomGuy);
            doomGuyBBox.min.x -= 3;
            doomGuyBBox.min.y -= 3;
            doomGuyBBox.min.z -= 3;
            doomGuyBBox.max.x += 3;
            doomGuyBBox.max.y += 3;
            doomGuyBBox.max.z += 3;
            if (doomGuyBBox.containsPoint(camera.position) && !seeDoomGuy) {
                scene = scene2;
            }

        }

        function setSkullBBoxs() {
            skullBBox = new THREE.Box3();
            skullBBox.setFromObject(skull);
            skullBBox.min.x -= 5;
            skullBBox.min.y -= 5;
            skullBBox.min.z -= 5;
            skullBBox.max.x += 5;
            skullBBox.max.y += 5;
            skullBBox.max.z += 5;
            skullBBox2 = new THREE.Box3();
            skullBBox2.setFromObject(skull2);
            skullBBox2.min.x -= 5;
            skullBBox2.min.y -= 5;
            skullBBox2.min.z -= 5;
            skullBBox2.max.x += 5;
            skullBBox2.max.y += 5;
            skullBBox2.max.z += 5;
            skullBBox3 = new THREE.Box3();
            skullBBox3.setFromObject(skull3);
            skullBBox3.min.x -= 5;
            skullBBox3.min.y -= 5;
            skullBBox3.min.z -= 5;
            skullBBox3.max.x += 5;
            skullBBox3.max.y += 5;
            skullBBox3.max.z += 5;
        }

        function rotateSkulls() {
            skull.rotateY(.1);
            skull2.rotateY(.1);
            skull3.rotateY(.1);
        }

        function checkSkulls() {

            //Count amount of skulls collected & setting visibility
            if (skullBBox.containsPoint(camera.position) && skull.visible) {
                skullCount++;
            }

            //checks if camera is touching skulls BBox, and if the skull is visible
            //if so, the collect sound is played, and the skull is visibility is set to false
            if (skullBBox.containsPoint(camera.position) && skull.visible) {
                skullCollectSound();
                skull.visible = false;
            }

            if (skullBBox2.containsPoint(camera.position) && skull2.visible) {
                skullCount++;
            }

            if (skullBBox2.containsPoint(camera.position) && skull2.visible) {
                skullCollectSound();
                skull2.visible = false;
            }

            if (skullBBox3.containsPoint(camera.position) && skull3.visible) {
                skullCount++;
            }

            if (skullBBox3.containsPoint(camera.position) && skull3.visible) {
                skullCollectSound();
                skull3.visible = false;
            }
        }

        function skullCollectSound() {
            //Collect audio
            var collectSound = new THREE.Audio(listener);
            audioLoader.load('js/Sounds/collect_sound.ogg', function (buffer) {
                collectSound.setBuffer(buffer);
                collectSound.setLoop(false);
                collectSound.setVolume(.1);
                collectSound.play();
            });

        }

        function checkLevelProgression() {
            if (skullCount == 3 && building.visible == false) {
                building.visible = true;
                house.visible = false;
            }
        }

        function follow() {
            doomGuy.rotation.y = Math.atan2((camera.position.x - doomGuy.position.x), (camera.position.z - doomGuy.position.z));
        }




        var animate = function () {
            cubeBBox.setFromObject(cube);
            rotateSkulls();
            checkSkulls();
            checkLevelProgression();
            checkDeath();
            follow();
            dt = (Date.now() - lastFrame) / 1000

            if (mixer) {
                mixer.update(dt)
            }

            lastFrame = Date.now()

            requestAnimationFrame(animate);
        //    menuSystem();
            updateRaycasters();

            if (seeDoomGuy == false && seeTitleScreen == false) {

                doomGuyChase();
                walk.play();
            }
            if (controlsEnabled) {

                var delta = .5;

                if (moveForward) {
                    controls.getObject().translateZ(-delta);
                }
                if (moveBackward) {
                    controls.getObject().translateZ(delta);
                }
                if (moveLeft) {
                    controls.getObject().translateX(-delta);
                }
                if (moveRight) {
                    controls.getObject().translateX(delta);
                }

                if (collisionsD[0]) {
                    controls.getObject().position.y = collisionsD[0].point.y + 2.5;
                }
                for (i = 0; i < buildingBBoxes.length; i++) {
                        if (moveForward && buildingBBoxes[i].containsPoint(camera.position)) {
                            moveForward = false;
                            controls.getObject().translateZ(delta);
                        }
                        if (moveBackward && buildingBBoxes[i].containsPoint(camera.position)) {
                            moveBackward = false;
                            controls.getObject().translateZ(-delta);
                        }
                        if (moveLeft && buildingBBoxes[i].containsPoint(camera.position)) {
                            moveLeft = false;
                            controls.getObject().translateX(delta);
                        }
                        if (moveRight && buildingBBoxes[i].containsPoint(camera.position)) {
                            moveRight = false;
                            controls.getObject().translateX(-delta);
                        }
                 }
				
				if (house.visible) {
                    for (i = 0; i < houseBBoxCount; i++) {
                        if (moveForward && houseBBoxes[i].containsPoint(camera.position)) {
                            moveForward = false;
                            controls.getObject().translateZ(delta);
                        }
                        if (moveBackward && houseBBoxes[i].containsPoint(camera.position)) {
                            moveBackward = false;
                            controls.getObject().translateZ(-delta);
                        }
                        if (moveLeft && houseBBoxes[i].containsPoint(camera.position)) {
                            moveLeft = false;
                            controls.getObject().translateX(delta);
                        }
                        if (moveRight && houseBBoxes[i].containsPoint(camera.position)) {
                            moveRight = false;
                            controls.getObject().translateX(-delta);
                        }
                    }
                }
            }
            renderer.render(scene, camera);


            if (doomGuy.position.y != -2) {
                doomGuy.position.y = -2;
            }
        };
        function logDirection() {
            console.log(camera.position);


            //console.log(doomGuyBBox);
            //console.log(skull);
            //console.log(skullCount);
            //console.log(doomGuyBBox.containsPoint(camera.position));
            //console.log(controls.getObject().position);
            //console.log(directionR);
        }


    </script>
</body>
</html>